# 提示词集合（面向 Cursor / Trae，完整结构版）

说明：
- 本文档从本次对话中提炼“明确目标的问题”，并将其专业提示词化，便于直接复制到 Cursor / Trae 使用。
- 每条均按「原话 → 提示词化（完整结构） → 使用场景」组织。

---

## 1) 商业级架构评估：毫不留情挑刺（对齐同行标准）

### 原话
请你作为一名资深的python架构师，拥有大量商业级项目的架构经验，请对项目进行专业的评估，毫无留情的给它挑刺，全面指出它的不足之处。目标是对齐商业级项目，能让同行不觉得它水平低。

### 提示词化（完整结构）
你是一名资深 Python 架构师与商业级项目评审专家。请对我提供的 Python 项目做一次“同行评审级别”的严格审计与挑刺，输出可落地的改进建议。

- 背景：该项目当前可运行，但工程化程度不足，担心在同业评审中显得不专业。
- 目标：从商业级项目标准出发，全面指出不足，并给出优先级明确的改造路线图。
- 范围：代码结构、模块边界、依赖管理、配置管理、可测试性、异常处理、日志策略、可维护性、安全性、跨平台/打包发布、用户体验（若为 GUI/CLI）。
- 约束：
  - 不凭空假设依赖/环境；以项目现状为准。
  - 指出问题必须给出证据（文件位置/调用链/具体风险）。
  - 建议必须可执行（明确改什么、影响什么、如何验收）。
- 交付物：
  1) 问题清单：按严重级别（P0/P1/P2）分类，每条包含：现象、风险、证据、建议。
  2) 架构改造路线图：按阶段拆解（1–2 天可完成 / 1 周 / 1 月），并说明收益。
  3) 工程规范建议：测试策略、格式化、Lint、类型检查、CI、发布与版本管理建议。
- 验收标准：
  - 输出内容足够让工程师直接开工；每条建议可被验证；优先级合理。
- 输出格式：使用 Markdown，包含目录与分级标题；问题条目用表格或固定模板呈现。

### 使用场景
当你要把一个“能跑的脚本/小工具”提升到“同行看起来专业、可维护、可扩展、可交付”的商业级水准时。

---

## 2) 评估并改造目录组织：UI 目录按职责分层（进一步管理组织）

### 原话
你是一名专业的python架构师，请评估目前文件拆分后的代码文件的组织结构，是否需要调整？举例：目前 ui 目录下，存在各种用途的代码文件，是不是需要更进一步进行管理组织？

### 提示词化（完整结构）
你是一名资深 Python 架构师。请评估并改造项目的目录结构，使其符合商业级项目的可维护性标准，重点处理“单目录职责混杂”的问题。

- 背景：某些目录（例如 UI 相关目录）混杂主题/图标/窗口工具/页面/组件/平台依赖等不同职责代码，导致定位困难、改动牵连大。
- 目标：形成清晰的职责边界与稳定导入路径，降低耦合与重复。
- 范围：目标目录及其子模块（如 pages/components/dialogs/style/platform/utils），以及与核心模块的依赖关系。
- 约束：
  - 不改变功能与界面行为；不改变文案与交互；不新增第三方依赖。
  - 遵循现有代码风格；不添加注释。
- 执行步骤：
  1) 盘点现状：每个文件的职责、被谁引用、是否存在重复实现/循环依赖。
  2) 给出目标结构：按职责分层，并说明每类文件的归属规则。
  3) 以低风险方式落地：先迁移实现到新目录，再保留兼容导出（re-export）。
  4) 完成引用迁移后删除兼容垫片，并再次扫描确保无残留。
- 交付物：
  - 新旧目录对照表（文件迁移到哪里、为什么）
  - 依赖边界说明（哪些层允许依赖哪些层）
  - 验证命令与结果
- 验收标准：
  - 目录结构一眼可懂；无循环依赖；无重复实现；全量测试通过。

### 使用场景
当目录逐步演化成“杂物间”，任何小改动都要全局搜一遍，且难以保证不引入回归时。

---

## 3) 低风险推进重构：小步、可回滚、强制验证闭环

### 原话
重构时尽可能先跑通自测用例，再改造，再跑通。

### 提示词化（完整结构）
你是一名偏执的工程质量守门员。请在不改变行为的前提下推进重构，并严格执行“改动前验证—改动后验证”的闭环，任何一步都必须可回滚。

- 背景：重构容易引入隐性回归（路径引用、循环依赖、漏迁移文件、启动时序变化）。
- 目标：以最小风险完成结构优化与代码治理。
- 范围：本次重构涉及的所有模块与测试。
- 约束：
  - 每次改动必须是可审查的小步；避免一次性大搬家。
  - 必须给出可复现的验证命令与结果摘要。
- 执行步骤：
  1) 记录改动前基线（测试/编译检查）。
  2) 单次只做一种语义变更（例如“移动模块并保留兼容导出”）。
  3) 立即运行验证并修复失败。
  4) 重复迭代直至完成。
- 交付物：变更摘要、验证结果、风险点与处理方式。
- 验收标准：全套验证通过；行为一致；改动可读、可回滚。

### 使用场景
当你希望 AI 输出的改造可以直接合入并长期维护，而不是“看起来合理但未验证”的改动时。

---

## 4) 两阶段迁移策略：先兼容导出，再迁移引用，最后删除垫片

### 原话
整理到新目录但要保留兼容；之后再删除冗余文件。

### 提示词化（完整结构）
你是一名擅长“不中断用户使用的重构迁移”的 Python 架构师。请为项目制定并执行两阶段迁移策略：先兼容、再清理。

- 背景：直接移动文件会导致大量导入断裂；一次性修改风险过大。
- 目标：实现无痛迁移：功能不变、引用平滑过渡、最终彻底清理旧文件。
- 范围：被迁移的模块及其所有调用方（含测试与入口）。
- 约束：
  - 第一阶段允许存在 re-export 垫片，但必须明确为临时过渡。
  - 第二阶段必须清除垫片并完成引用统一。
- 执行步骤：
  1) 新目录落地真实实现（新模块成为唯一权威来源）。
  2) 旧路径保留薄垫片，仅转发新实现。
  3) 批量迁移调用方导入到新路径。
  4) 扫描并确认无旧路径引用后，删除垫片文件。
- 交付物：迁移计划、删除清单、引用扫描证据、验证结果。
- 验收标准：无旧路径引用；无重复实现；测试全绿。

### 使用场景
任何需要“边跑边换轮胎”的重构：模块改名、目录调整、API 收口、平台适配层抽离等。

---

## 5) 重构后清理冗余：确保无废弃文件/死代码残留

### 原话
到这里，咱们先停下重构的脚本，重构之后应该产生了很多多余文件。请持有严谨的态度梳理项目，确保没有冗余废弃的代码文件。

### 提示词化（完整结构）
你是一名严谨的 Python 代码库维护者。请对项目进行一次“重构后清理审计”，目标是删除冗余、废弃、重复与无引用文件，并确保行为不变。

- 背景：近期进行了目录整理/模块迁移，可能遗留兼容垫片、重复实现、旧文件未删等技术债。
- 目标：在不改变功能行为的前提下，清理冗余文件与死代码，降低长期维护成本。
- 范围：
  - 未被引用的模块/函数/常量
  - 仅做 re-export 的兼容垫片文件
  - 重复工具函数/重复配置项/重复资源
  - 入口脚本与测试代码的引用一致性
- 约束：
  - 删除必须证据驱动：给出全项目引用扫描依据（导入引用、动态加载、入口路径）。
  - 先迁移引用再删文件；禁止凭感觉删除。
  - 改动后必须通过全量测试/基础运行验证。
- 执行步骤：
  1) 列出项目内所有模块清单（按目录分组）。
  2) 扫描引用关系，标记：强引用 / 可能动态引用 / 未引用。
  3) 对“未引用/仅兼容垫片”制定迁移与删除计划。
  4) 执行删除与引用更新。
  5) 运行测试与基础启动验证。
- 交付物：
  - 删除/合并/迁移清单（含理由与替代路径）
  - 引用迁移结果（哪些文件的 import 被改到哪里）
  - 验证命令与通过结果
- 验收标准：
  - 无残留旧路径导入；测试全绿；运行入口正常；仓库中不存在“无人引用的历史文件”。

### 使用场景
当你完成一轮重构后，希望干净收尾，避免项目里长期堆积旧文件、兼容文件与重复实现。

---

## 6) 排查“首次启动不记历史，第二次才记住”：定位读写与覆盖根因

### 原话
现在是在代码中写死了逻辑吗：启动就把 history.json 改成某个内容？我每次运行第一次没有记录上次的，第二次打开就能记住了。

### 提示词化（完整结构）
你是一名擅长定位“冷启动/首次启动异常”的 Python 工程师。请排查本地持久化历史记录（例如 history.json）出现“第一次启动不加载历史、第二次才正常”的问题，并提供可验证的修复方案。

- 背景：历史记录在界面上表现不稳定：首次运行不显示上次历史；二次运行又能恢复。怀疑启动覆盖写、读取失败被吞、或异常退出导致文件损坏。
- 目标：明确问题根因并修复，使历史记录在每次启动都可靠加载，且不会被静默覆盖。
- 范围：历史管理模块（读取/清洗/保存）、入口启动流程、UI 刷新时机、异常处理策略。
- 约束：
  - 不改变业务与 UI 行为；仅提升可靠性与可观测性。
  - 兼容旧历史数据格式（如字符串/字典混合）。
  - 修复需覆盖异常场景：半写文件、损坏 JSON、权限/路径不可写。
- 执行步骤：
  1) 标注历史的读取时机与写入触发点（调用链与入口路径）。
  2) 复现并确认是“读取失败”还是“被覆盖写入”。
  3) 若存在文件损坏风险：实现原子写入（临时文件 + replace）。
  4) 若存在读取失败吞异常：实现损坏隔离（保留损坏副本，避免覆盖）。
  5) 增加回归测试覆盖上述边界条件。
- 交付物：
  - 根因说明（对应代码位置与触发路径）
  - 修复设计（为何可解决、是否兼容）
  - 新增/更新测试用例清单
  - 验证命令与结果
- 验收标准：
  - 连续多次启动均可加载历史；异常退出后不再出现历史丢失；损坏文件可被保留追溯；测试全绿。

### 使用场景
当你有任何本地持久化（JSON/YAML/INI/SQLite）在异常退出、首次启动或跨版本迁移时出现不稳定表现。

