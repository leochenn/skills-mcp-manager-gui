# Python 商业级重构经验总结（可复用模板｜工程规范 + 架构兼顾）

说明：
- 本文档从本次对话中抽象出“可复用到任意 Python 项目”的重构方法与工程实践。
- 目标是把“能跑的代码”提升到“可维护、可扩展、可交付、同行认可”的商业级规格。

---

## 1) 重构闭环：先基线验证，再改造，再回归验证

- 重构前先跑通现有验证（至少语法检查/编译检查 + 单元测试），记录为基线。
- 重构后必须重复同一套验证，必要时补充回归用例覆盖新引入的边界。
- 将“看起来没问题”变成“可证明没回归”。

---

## 2) 小步、可回滚：渐进式迁移优于一次性大搬家

- 将结构调整拆成可控的多步：每步只做一种语义变更。
- 优先采用“先落地新实现、再迁移引用、最后删除旧文件”的策略，避免风险叠加。
- 每步都能独立审查与回滚，避免重构变成不可控的大工程。

---

## 3) 兼容垫片是债：必须有删除条件与终点

- 兼容导出（re-export）适合过渡期，能降低迁移成本，但它本质是技术债。
- 必须明确删除条件：
  - 全项目无旧路径引用；
  - 测试全绿；
  - 入口启动验证通过；
  - 引用扫描无残留。
- 达成条件后立即删除垫片，避免长期误导维护者。

---

## 4) 清理冗余必须证据驱动：删前做引用扫描，删后做残留扫描

- 删除文件/模块前要证明：
  - 项目入口与测试均不依赖；
  - 静态导入与可能的动态导入都已排除；
  - 或者该文件仅是兼容转发，且调用方已全部迁移。
- 删除后再扫描一次，确保无残留旧路径导入与隐性引用。
- 这是把“清理”变成工程化动作，而非凭直觉的“扫地”。

---

## 5) 目录组织以职责边界为核心，而不是以文件大小或个人习惯

通用的职责分层（名称可变，关键是边界）：
- 平台/依赖封装层：隔离 GUI 库、图像库、系统差异，避免全项目散落依赖导入。
- 样式/展示规则层：主题色、图标资源、状态到颜色映射等展示规则，尽量与业务解耦。
- 通用工具层：窗口居中、对话框、路径处理等可复用工具。
- 页面/组件层：页面负责编排与流程；组件承载可复用 UI 单元。
- 核心业务层：不依赖 UI；只提供可测试、可复用的业务能力。

---

## 6) 包接口治理：顶层轻量无副作用，子包入口稳定可预期

- 顶层包（例如某个大模块的 `__init__.py`）应避免导入重依赖模块，避免导入时副作用与循环依赖。
- 子包可以提供聚合导出入口，让调用方从稳定路径导入公共能力，减少内部路径泄漏。
- 形成“对外接口稳定、对内结构可演进”的长期收益。

---

## 7) 本地持久化要按商业级可靠性处理（哪怕只是 JSON 文件）

即使不引入数据库，本地文件持久化也应满足最小可靠性：
- 原子写入：写临时文件、flush/fsync、再 replace，避免异常退出产生半截文件。
- 损坏隔离：读取失败时保留损坏副本，避免静默覆盖导致数据不可恢复。
- 兼容清洗：支持旧数据格式，加载时统一为新结构并去重、裁剪。
- 回归测试：覆盖损坏文件、空文件、旧格式混合、重复去重、上限裁剪、权限/路径问题。

---

## 8) “第一次不生效、第二次才正常”的通用排查框架

- 先画出读写时序：启动读？进入页面写？退出写？是否存在覆盖写？
- 优先检查异常吞噬：`except: pass` 往往把根因隐藏成偶发问题。
- 检查部分写入风险：直接覆盖写 JSON/YAML 最容易在异常退出后损坏。
- 将用户现象转化为自动化用例，再修复，最后用测试锁住回归。

---

## 9) 用测试驱动重构与修复：让交付可证明

- 重构/修复不是“改完能跑”就结束，而是要把关键风险固化成测试。
- 测试用例应覆盖：
  - 关键边界输入；
  - 历史格式兼容；
  - 异常路径（例如损坏文件、不可写路径）。
- 目标是让未来任何改动都不会把同类问题带回来。

---

## 10) 每次工程交付的三件套：变更清单、行为边界、验证结果

- 变更清单：新增/修改/删除了哪些文件与模块。
- 行为边界：哪些属于纯重构不改行为，哪些属于缺陷修复或功能调整。
- 验证结果：可复现的命令与通过输出摘要。

这三件套能显著提升 Code Review 质量与团队协作效率，也让项目更像商业级工程而不是个人脚本。

